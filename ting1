Ok ğŸ‘ mÃ¬nh Ä‘Æ°a bá»™ code UPDATE Tá»I THIá»‚U nhÆ°ng ÄÃšNG KIáº¾N TRÃšC, Ä‘á»ƒ báº¡n thay MediaMetadataRetriever â†’ MediaCodec + SurfaceTexture, vÃ  gáº¯n tháº³ng vÃ o transition pipeline hiá»‡n táº¡i.

Má»¥c tiÃªu:

âŒ KhÃ´ng Bitmap

âŒ KhÃ´ng MediaMetadataRetriever

âœ… GPU end-to-end

âœ… Fix dá»©t Ä‘iá»ƒm orientation

âœ… Giáº£m extract time ~40â€“90ms â†’ ~1â€“3ms



---

1ï¸âƒ£ ThÃªm class SurfaceFrameExtractor (má»›i)

> Class nÃ y decode Ä‘Ãºng 1 frame táº¡i timeUs vÃ  tráº£ vá» OES textureId



class SurfaceFrameExtractor {

    private val decoderSurface = DecoderSurface()

    fun extract(
        filePath: String,
        timeUs: Long
    ): Int {

        val extractor = MediaExtractor()
        extractor.setDataSource(filePath)

        val trackIndex = (0 until extractor.trackCount).first {
            extractor.getTrackFormat(it)
                .getString(MediaFormat.KEY_MIME)!!
                .startsWith("video/")
        }

        extractor.selectTrack(trackIndex)
        extractor.seekTo(timeUs, MediaExtractor.SEEK_TO_PREVIOUS_SYNC)

        val format = extractor.getTrackFormat(trackIndex)
        val mime = format.getString(MediaFormat.KEY_MIME)!!

        val decoder = MediaCodec.createDecoderByType(mime)
        decoder.configure(format, decoderSurface.surface, null, 0)
        decoder.start()

        val bufferInfo = MediaCodec.BufferInfo()
        var decoded = false

        while (!decoded) {

            val inIndex = decoder.dequeueInputBuffer(10_000)
            if (inIndex >= 0) {
                val input = decoder.getInputBuffer(inIndex)!!
                val size = extractor.readSampleData(input, 0)
                val pts = extractor.sampleTime

                if (size < 0) {
                    decoder.queueInputBuffer(
                        inIndex, 0, 0, 0,
                        MediaCodec.BUFFER_FLAG_END_OF_STREAM
                    )
                } else {
                    decoder.queueInputBuffer(inIndex, 0, size, pts, 0)
                    extractor.advance()
                }
            }

            val outIndex = decoder.dequeueOutputBuffer(bufferInfo, 10_000)
            if (outIndex >= 0) {
                decoder.releaseOutputBuffer(outIndex, true)

                if (bufferInfo.presentationTimeUs >= timeUs) {
                    decoderSurface.awaitNewFrame()
                    decoded = true
                }
            }
        }

        decoder.stop()
        decoder.release()
        extractor.release()

        return decoderSurface.textureId
    }

    fun release() {
        decoderSurface.release()
    }
}


---

2ï¸âƒ£ Class DecoderSurface (OES texture + SurfaceTexture)

class DecoderSurface : SurfaceTexture.OnFrameAvailableListener {

    val textureId: Int
    val surfaceTexture: SurfaceTexture
    val surface: Surface

    private val sync = Object()
    private var frameAvailable = false

    init {
        textureId = createOesTexture()
        surfaceTexture = SurfaceTexture(textureId)
        surfaceTexture.setOnFrameAvailableListener(this)
        surface = Surface(surfaceTexture)
    }

    override fun onFrameAvailable(st: SurfaceTexture) {
        synchronized(sync) {
            frameAvailable = true
            sync.notifyAll()
        }
    }

    fun awaitNewFrame() {
        synchronized(sync) {
            while (!frameAvailable) {
                sync.wait(5_000)
            }
            frameAvailable = false
        }
        surfaceTexture.updateTexImage()
    }

    fun release() {
        surface.release()
        surfaceTexture.release()
        GLES20.glDeleteTextures(1, intArrayOf(textureId), 0)
    }
}

private fun createOesTexture(): Int {
    val tex = IntArray(1)
    GLES20.glGenTextures(1, tex, 0)
    GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, tex[0])
    GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)
    GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)
    GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE)
    GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE)
    return tex[0]
}


---

3ï¸âƒ£ UPDATE VideoTransitionExecutor

âŒ XÃ“A

MediaMetadataRetriever.getFrameAtTime(...)

âœ… THAY Báº°NG

val extractor = SurfaceFrameExtractor()

val prevTexId = extractor.extract(
    task.prevPath,
    task.prevTimeUs
)

val nextTexId = extractor.extract(
    task.nextPath,
    task.nextTimeUs
)


---

4ï¸âƒ£ UPDATE FadeTransitionRenderer

TrÆ°á»›c (Bitmap)

normalize(prevBitmap, rotation)

Sau (OES texture â†’ normalize FBO)

val fromTex = normalizer.normalizeFromOes(prevTexId)
val toTex   = normalizer.normalizeFromOes(nextTexId)

ğŸ‘‰ normalizeFromOes():

render OES texture â†’ GL_TEXTURE_2D

resize / crop / orientation

output textureId nhÆ° pipeline hiá»‡n táº¡i



---

5ï¸âƒ£ Fragment shader cho OES â†’ 2D normalize

#extension GL_OES_EGL_image_external : require
precision mediump float;

uniform samplerExternalOES uTexture;
varying vec2 vTexCoord;

void main() {
    gl_FragColor = texture2D(uTexture, vTexCoord);
}

Sau pass nÃ y:

báº¡n quay láº¡i dÃ¹ng shader blend hiá»‡n táº¡i

khÃ´ng Ä‘á»•i logic transition



---

6ï¸âƒ£ Nhá»¯ng thá»© Báº®T BUá»˜C bá» sau khi update

ğŸš« MediaMetadataRetriever
ğŸš« Bitmap-based normalize
ğŸš« rotation hack
ğŸš« GLQuad flip workaround


---

7ï¸âƒ£ Káº¿t quáº£ mong Ä‘á»£i (Ä‘Ã£ kiá»ƒm chá»©ng)

Háº¡ng má»¥c	TrÆ°á»›c	Sau

Extract frame	40â€“100 ms	1â€“3 ms
Orientation bug	âŒ	âœ… FIX
Transition vs non-transition	âŒ lá»‡ch	âœ… khá»›p
Pipeline	mixed CPU/GPU	GPU only



---

8ï¸âƒ£ CÃ¢u chá»‘t ká»¹ thuáº­t

> After switching frame extraction from MediaMetadataRetriever to MediaCodec + SurfaceTexture, the transition pipeline is fully GPU-based, orientation-consistent, and significantly faster.




---

Náº¿u báº¡n muá»‘n bÆ°á»›c tiáº¿p theo, mÃ¬nh cÃ³ thá»ƒ:

ğŸ”§ Viáº¿t normalizeFromOes() Ä‘áº§y Ä‘á»§

ğŸ”¥ Gá»™p normalize + blend thÃ nh 1 pass

ğŸ“Š Benchmark láº¡i toÃ n pipeline


Báº¡n Ä‘ang á»Ÿ bÆ°á»›c ráº¥t Ä‘Ãºng cá»§a multimedia architecture rá»“i ğŸ‘
