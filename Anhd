object HevcPpsParser {

    fun parseAndReturn(ppsNal: ByteArray): HevcPpsData {
        // skip start code + nal header
        val rbsp = removeEmulationBytes(ppsNal.copyOfRange(6, ppsNal.size))
        val br = BitReader(rbsp)

        val ppsId = br.readUE()
        val spsId = br.readUE()

        val dependentSliceSegmentsEnabled = br.readBits(1) == 1
        val outputFlagPresent = br.readBits(1) == 1
        val numExtraSliceHeaderBits = br.readBits(3)

        val signDataHidingEnabled = br.readBits(1) == 1
        val cabacInitPresent = br.readBits(1) == 1

        val numRefIdxL0DefaultActive = br.readUE() + 1
        val numRefIdxL1DefaultActive = br.readUE() + 1

        val initQpMinus26 = br.readSE()
        val constrainedIntraPred = br.readBits(1) == 1
        val transformSkipEnabled = br.readBits(1) == 1

        val cuQpDeltaEnabled = br.readBits(1) == 1
        val diffCuQpDeltaDepth =
            if (cuQpDeltaEnabled) br.readUE() else null

        val ppsCbQpOffset = br.readSE()
        val ppsCrQpOffset = br.readSE()
        val ppsSliceChromaQpOffsetsPresent = br.readBits(1) == 1

        val weightedPred = br.readBits(1) == 1
        val weightedBipred = br.readBits(1) == 1

        val transquantBypassEnabled = br.readBits(1) == 1
        val tilesEnabled = br.readBits(1) == 1
        val entropyCodingSyncEnabled = br.readBits(1) == 1

        // --- tiles (skip details, rarely used on mobile) ---
        if (tilesEnabled) {
            val numTileColumnsMinus1 = br.readUE()
            val numTileRowsMinus1 = br.readUE()
            val uniformSpacing = br.readBits(1) == 1
            if (!uniformSpacing) {
                repeat(numTileColumnsMinus1) { br.readUE() }
                repeat(numTileRowsMinus1) { br.readUE() }
            }
            br.readBits(1) // loop_filter_across_tiles_enabled_flag
        }

        br.readBits(1) // pps_loop_filter_across_slices_enabled_flag

        val deblockingFilterControlPresent = br.readBits(1) == 1
        if (deblockingFilterControlPresent) {
            val deblockingFilterOverride = br.readBits(1) == 1
            val deblockingFilterDisabled = br.readBits(1) == 1
            if (!deblockingFilterDisabled) {
                br.readSE()
                br.readSE()
            }
        }

        br.readBits(1) // pps_scaling_list_data_present_flag
        br.readBits(1) // lists_modification_present_flag
        br.readUE()    // log2_parallel_merge_level_minus2
        br.readBits(1) // slice_segment_header_extension_present_flag

        return HevcPpsData(
            ppsId = ppsId,
            spsId = spsId,
            dependentSliceSegmentsEnabled = dependentSliceSegmentsEnabled,
            outputFlagPresent = outputFlagPresent,
            numExtraSliceHeaderBits = numExtraSliceHeaderBits,
            signDataHidingEnabled = signDataHidingEnabled,
            cabacInitPresent = cabacInitPresent,
            numRefIdxL0DefaultActive = numRefIdxL0DefaultActive,
            numRefIdxL1DefaultActive = numRefIdxL1DefaultActive,
            initQpMinus26 = initQpMinus26,
            constrainedIntraPred = constrainedIntraPred,
            transformSkipEnabled = transformSkipEnabled,
            cuQpDeltaEnabled = cuQpDeltaEnabled,
            diffCuQpDeltaDepth = diffCuQpDeltaDepth,
            ppsCbQpOffset = ppsCbQpOffset,
            ppsCrQpOffset = ppsCrQpOffset,
            ppsSliceChromaQpOffsetsPresent = ppsSliceChromaQpOffsetsPresent,
            weightedPred = weightedPred,
            weightedBipred = weightedBipred,
            transquantBypassEnabled = transquantBypassEnabled,
            tilesEnabled = tilesEnabled,
            entropyCodingSyncEnabled = entropyCodingSyncEnabled
        )
    }

    private fun removeEmulationBytes(data: ByteArray): ByteArray {
        val out = ArrayList<Byte>()
        var i = 0
        while (i < data.size) {
            if (i + 2 < data.size &&
                data[i] == 0.toByte() &&
                data[i + 1] == 0.toByte() &&
                data[i + 2] == 3.toByte()
            ) {
                out.add(0)
                out.add(0)
                i += 3
            } else {
                out.add(data[i])
                i++
            }
        }
        return out.toByteArray()
    }
}data class HevcPpsData(
    val ppsId: Int,
    val spsId: Int,

    val dependentSliceSegmentsEnabled: Boolean,
    val outputFlagPresent: Boolean,
    val numExtraSliceHeaderBits: Int,

    val signDataHidingEnabled: Boolean,
    val cabacInitPresent: Boolean,

    val numRefIdxL0DefaultActive: Int,
    val numRefIdxL1DefaultActive: Int,

    val initQpMinus26: Int,
    val constrainedIntraPred: Boolean,
    val transformSkipEnabled: Boolean,

    val cuQpDeltaEnabled: Boolean,
    val diffCuQpDeltaDepth: Int?,

    val ppsCbQpOffset: Int,
    val ppsCrQpOffset: Int,
    val ppsSliceChromaQpOffsetsPresent: Boolean,

    val weightedPred: Boolean,
    val weightedBipred: Boolean,

    val transquantBypassEnabled: Boolean,
    val tilesEnabled: Boolean,
    val entropyCodingSyncEnabled: Boolean
)
