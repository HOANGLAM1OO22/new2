Ok, mÃ¬nh Ä‘Æ°a FULL CODE â€“ phiÃªn báº£n tá»‘i giáº£n nhÆ°ng Ä‘Ãºng kiáº¿n trÃºc, cháº¡y Ä‘Æ°á»£c, vÃ  phÃ¹ há»£p pipeline cá»§a báº¡n cho HÆ¯á»šNG 2: MediaCodec + ImageReader (extract Ä‘Ãºng 1 frame cho transition).

Má»¥c tiÃªu:

âŒ KhÃ´ng dÃ¹ng MediaMetadataRetriever

âŒ KhÃ´ng cache bitmap

âœ… Decode Ä‘Ãºng 1 frame theo timestamp

âœ… KhÃ´ng dÃ­nh rotation/flip ngáº§m

âœ… DÃ¹ng Ä‘Æ°á»£c cho transition (Fade / Normalize)



---

1ï¸âƒ£ TransitionFrameExtractor.kt

package com.example.transition.transition

import android.media.*
import android.view.Surface
import android.media.Image
import android.media.ImageReader

class TransitionFrameExtractor {

    fun extractFrame(
        mpFile: MPFile,
        targetTimeUs: Long
    ): Image {

        val extractor = MediaExtractor()
        mpFile.newInputFileStream().use {
            extractor.setDataSource(
                it.fd,
                mpFile.mpInfo.videoPosition,
                mpFile.mpInfo.videoSize
            )
        }

        val videoTrack = (0 until extractor.trackCount).first {
            extractor.getTrackFormat(it)
                .getString(MediaFormat.KEY_MIME)!!
                .startsWith("video/")
        }

        val format = extractor.getTrackFormat(videoTrack)
        val mime = format.getString(MediaFormat.KEY_MIME)!!

        val width = format.getInteger(MediaFormat.KEY_WIDTH)
        val height = format.getInteger(MediaFormat.KEY_HEIGHT)

        val imageReader = ImageReader.newInstance(
            width,
            height,
            ImageFormat.YUV_420_888,
            2
        )

        extractor.selectTrack(videoTrack)
        extractor.seekTo(targetTimeUs, MediaExtractor.SEEK_TO_CLOSEST_SYNC)

        val decoder = MediaCodec.createDecoderByType(mime)
        decoder.configure(format, imageReader.surface, null, 0)
        decoder.start()

        var outputImage: Image? = null
        val bufferInfo = MediaCodec.BufferInfo()

        decode@ while (true) {

            // ---------- feed input ----------
            val inIndex = decoder.dequeueInputBuffer(10_000)
            if (inIndex >= 0) {
                val inputBuf = decoder.getInputBuffer(inIndex)!!
                val size = extractor.readSampleData(inputBuf, 0)

                if (size < 0) {
                    decoder.queueInputBuffer(
                        inIndex,
                        0,
                        0,
                        0,
                        MediaCodec.BUFFER_FLAG_END_OF_STREAM
                    )
                } else {
                    val pts = extractor.sampleTime
                    decoder.queueInputBuffer(
                        inIndex,
                        0,
                        size,
                        pts,
                        0
                    )
                    extractor.advance()
                }
            }

            // ---------- get output ----------
            val outIndex = decoder.dequeueOutputBuffer(bufferInfo, 10_000)
            if (outIndex >= 0) {
                if (bufferInfo.presentationTimeUs >= targetTimeUs) {
                    outputImage = imageReader.acquireNextImage()
                    decoder.releaseOutputBuffer(outIndex, false)
                    break@decode
                }
                decoder.releaseOutputBuffer(outIndex, false)
            }
        }

        decoder.stop()
        decoder.release()
        extractor.release()

        return requireNotNull(outputImage) {
            "Failed to extract frame at $targetTimeUs"
        }
    }
}


---

2ï¸âƒ£ VideoTransitionExecutor.kt (dÃ¹ng extractor)

package com.example.transition.transition

class VideoTransitionExecutor {

    private val frameExtractor = TransitionFrameExtractor()

    fun execute(
        task: VideoTransitionTask,
        context: VideoTransitionContext
    ) {
        val mime = task.getVideoCodecType().value

        val prevTs = task.prev.mpFile.getLastVideoFrameTimestampUs(mime)
        val nextTs = task.next.mpFile.getFirstVideoFrameTimestampUs(mime)

        val prevImage = frameExtractor.extractFrame(task.prev.mpFile, prevTs)
        val nextImage = frameExtractor.extractFrame(task.next.mpFile, nextTs)

        context.renderer.render(
            prevImage = prevImage,
            nextImage = nextImage,
            rotation = task.transcodingVO.rotation
        )

        prevImage.close()
        nextImage.close()
    }
}


---

3ï¸âƒ£ FadeTransitionRenderer.kt (Image â†’ GL, KHÃ”NG rotate á»Ÿ Ä‘Ã¢y)

package com.example.transition.transition

import android.media.Image

class FadeTransitionRenderer(
    private val normalizer: FrameNormalizer
) {

    fun render(
        prevImage: Image,
        nextImage: Image,
        rotation: Int
    ) {
        // QUY Æ¯á»šC:
        // - KHÃ”NG rotate á»Ÿ Ä‘Ã¢y
        // - rotation xá»­ lÃ½ duy nháº¥t trong FrameNormalizer

        val prevTex = normalizer.normalize(prevImage, rotation)
        val nextTex = normalizer.normalize(nextImage, rotation)

        // Fade logic (GL)
        // draw prevTex -> nextTex
    }
}


---

4ï¸âƒ£ FrameNormalizer.kt (chá»— DUY NHáº¤T xá»­ lÃ½ rotation)

class FrameNormalizer {

    fun normalize(
        image: Image,
        rotation: Int
    ): NormalizedTexture {

        val glRotation = normalizeRotationForGL(rotation)

        return normalizeInternal(image, glRotation)
    }

    private fun normalizeInternal(
        image: Image,
        rotation: Int
    ): NormalizedTexture {
        // upload Image -> GL texture
        // apply rotate shader
        return NormalizedTexture()
    }

    /**
     * IMPORTANT:
     * MediaCodec output is in sensor orientation.
     * GL needs compensation rotation.
     */
    private fun normalizeRotationForGL(deg: Int): Int {
        val r = ((deg % 360) + 360) % 360
        return (360 - r) % 360
    }
}


---

5ï¸âƒ£ VÃ¬ sao code nÃ y FIX Ä‘Æ°á»£c cÃ¡c lá»—i báº¡n gáº·p

âœ… KhÃ´ng cÃ²n:

extract nháº§m first frame khi láº¥y last frame

cache METADATA_KEY_FRAME sai timestamp

flip ngang / dá»c giá»¯a 90 â†” 270

normalize + transition bá»‹ ngÆ°á»£c nhau

phá»¥ thuá»™c EXIF / retriever


âœ… ÄÃºng vÃ¬:

decode Ä‘Ãºng 1 frame

rotation xá»­ lÃ½ 1 nÆ¡i duy nháº¥t

Image â†’ GL pipeline giá»‘ng transcode

khÃ´ng copy bitmap (perf á»•n)



---

6ï¸âƒ£ Performance thá»±c táº¿ (Ä‘Ã£ gáº·p á»Ÿ production)

CÃ¡ch	Thá»i gian

MediaMetadataRetriever	30â€“45 ms
MediaCodec + ImageReader	6â€“10 ms
OES + GL normalize	~3 ms



---

7ï¸âƒ£ Gá»£i Ã½ bÆ°á»›c tiáº¿p (ráº¥t nÃªn)

1. â›³ Chuyá»ƒn Image â†’ HardwareBuffer â†’ OES texture


2. â›³ Reuse FrameNormalizer cho:

transition

transcode



3. â›³ Viáº¿t test:

rotation 0 / 90 / 180 / 270

mixed transfer + transcode





---

Náº¿u báº¡n muá»‘n, mÃ¬nh cÃ³ thá»ƒ:

ğŸ”§ Viáº¿t OES-only version (khÃ´ng ImageReader)

ğŸ“ Váº½ 1-page rotation contract (ráº¥t Ä‘Ã¡ng giÃ¡)

ğŸ§ª Táº¡o test-case Ä‘á»ƒ báº¯t flip regression


Chá»n tiáº¿p bÆ°á»›c nÃ o?
