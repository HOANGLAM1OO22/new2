Ok, Ä‘i tháº³ng vÃ o Ä‘Ãºng chá»— báº¡n há»i nhÃ© ğŸ‘
DÆ°á»›i Ä‘Ã¢y lÃ  code dump chuáº©n Ä‘á»ƒ Ä‘áº·t trá»±c tiáº¿p trong writeTrack(channel), dÃ¹ng Ä‘á»ƒ debug encoder output â†’ muxer (case video/avc lá»—i frame).

MÃ¬nh giáº£ Ä‘á»‹nh:

channel = output channel tá»« encoder

bufferInfo lÃ  MediaCodec.BufferInfo

byteBuffer lÃ  data chuáº©n bá»‹ writeSampleData



---

1ï¸âƒ£ Dump H.264 ngay trong writeTrack(channel)

ğŸ”¹ Code máº«u (AN TOÃ€N â€“ KHÃ”NG áº¢NH HÆ¯á»NG LOGIC)

class AvcDumper(private val file: File) {
    private val fos = FileOutputStream(file)

    fun dump(buffer: ByteBuffer, info: MediaCodec.BufferInfo) {
        if (info.size <= 0) return

        val oldPos = buffer.position()
        val oldLimit = buffer.limit()

        buffer.position(info.offset)
        buffer.limit(info.offset + info.size)

        val data = ByteArray(info.size)
        buffer.get(data)
        fos.write(data)

        buffer.position(oldPos)
        buffer.limit(oldLimit)
    }

    fun close() {
        fos.flush()
        fos.close()
    }
}


---

2ï¸âƒ£ DÃ¹ng dumper trong writeTrack(channel)

private val videoDumper =
    AvcDumper(File(context.cacheDir, "dump_encoder_output.h264"))

fun writeTrack(
    channel: BufferChannel,
    byteBuffer: ByteBuffer,
    bufferInfo: MediaCodec.BufferInfo
) {
    // === DEBUG DUMP ===
    if (channel.mimeType == "video/avc") {
        videoDumper.dump(byteBuffer, bufferInfo)

        Log.d("DUMP_AVC", """
            PTS=${bufferInfo.presentationTimeUs}
            size=${bufferInfo.size}
            flags=${bufferInfo.flags}
            keyframe=${bufferInfo.flags and MediaCodec.BUFFER_FLAG_KEY_FRAME != 0}
            config=${bufferInfo.flags and MediaCodec.BUFFER_FLAG_CODEC_CONFIG != 0}
        """.trimIndent())
    }

    // === NORMAL FLOW ===
    mediaMuxer.writeSampleData(
        channel.trackIndex,
        byteBuffer,
        bufferInfo
    )
}

ğŸ“ Output file:

/data/data/xxx/cache/dump_encoder_output.h264


---

3ï¸âƒ£ Check file dump

ffplay -f h264 dump_encoder_output.h264

Káº¿t quáº£:

âŒ Náº¿u lá»—i frame â†’ encoder output Ä‘Ã£ sai

âœ” Náº¿u OK â†’ lá»—i á»Ÿ muxer / track config



---

4ï¸âƒ£ Dump riÃªng tá»«ng channel (náº¿u nhiá»u encoder)

Náº¿u báº¡n cÃ³ nhiá»u channel:

val dumpers = mutableMapOf<Int, AvcDumper>()

fun getDumper(trackIndex: Int): AvcDumper {
    return dumpers.getOrPut(trackIndex) {
        AvcDumper(File(context.cacheDir, "dump_track_$trackIndex.h264"))
    }
}

getDumper(channel.trackIndex).dump(byteBuffer, bufferInfo)


---

5ï¸âƒ£ Lá»–I Ráº¤T HAY Gáº¶P (Ä‘á»c ká»¹ Ä‘oáº¡n nÃ y)

â— KhÃ´ng dump codec config

Náº¿u báº¡n skip BUFFER_FLAG_CODEC_CONFIG, file dump sáº½ khÃ´ng play Ä‘Æ°á»£c

ğŸ‘‰ Dump Táº¤T Cáº¢, ká»ƒ cáº£ config:

// KHÃ”NG if (flags & CONFIG) skip


---

â— ByteBuffer bá»‹ modify trÆ°á»›c khi mux

âŒ Sai:

byteBuffer.position(info.offset + info.size)

âœ” ÄÃºng:

LuÃ´n restore position/limit sau dump



---

6ï¸âƒ£ Debug sÃ¢u hÆ¡n (ráº¥t há»£p case cá»§a báº¡n)

Log thÃªm:

if (bufferInfo.flags and MediaCodec.BUFFER_FLAG_END_OF_STREAM != 0) {
    Log.w("DUMP_AVC", "EOS received at PTS=${bufferInfo.presentationTimeUs}")
}

ğŸ‘‰ Náº¿u EOS Ä‘áº¿n trÆ°á»›c frame cuá»‘i â†’ chÃ­nh lÃ  bug báº¡n Ä‘ang gáº·p.


---

7ï¸âƒ£ Báº¡n nÃªn lÃ m tiáº¿p bÆ°á»›c nÃ o?

MÃ¬nh Ä‘á» xuáº¥t thá»© tá»±:

1. Dump encoder output H264 (code trÃªn)


2. ffplay kiá»ƒm tra


3. Náº¿u OK â†’ mÃ¬nh sáº½ giÃºp báº¡n fix muxer / track / csd


4. Náº¿u lá»—i â†’ soi encoder config / PTS / GL render



ğŸ‘‰ Náº¿u báº¡n muá»‘n, paste luÃ´n writeTrack() hiá»‡n táº¡i, mÃ¬nh sáº½ gáº¡ch Ä‘á» chÃ­nh xÃ¡c dÃ²ng gÃ¢y lá»—i cho case avc-only cá»§a báº¡n.
